<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.10.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>My Project: STM32RTC</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectlogo"><img alt="Logo" src="Doxyfile.cfg"/></td>
  <td id="projectalign">
   <div id="projectname">My Project
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.10.0 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

</div><!-- top -->
<div><div class="header">
  <div class="headertitle"><div class="title">STM32RTC</div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p><a class="anchor" id="autotoc_md0"></a>A RTC library for STM32.</p>
<h1><a class="anchor" id="autotoc_md1"></a>
Requirement</h1>
<ul>
<li><a href="https://github.com/stm32duino/Arduino_Core_STM32">Arduino_Core_STM32</a> version &gt;= 1.3.0</li>
</ul>
<h1><a class="anchor" id="autotoc_md2"></a>
API</h1>
<p>This library is based on the Arduino RTCZero library. The library allows to take control of the internal RTC of the STM32 boards.</p>
<p>Singleton design pattern is used to ensure that only one <a class="el" href="class_s_t_m32_r_t_c.html">STM32RTC</a> instance is instantiated: </p><div class="fragment"><div class="line"> ++</div>
<div class="line"><span class="comment">/* Get the rtc object */</span></div>
<div class="line"><a class="code hl_class" href="class_s_t_m32_r_t_c.html">STM32RTC</a>&amp; rtc = STM32RTC::getInstance();</div>
<div class="ttc" id="aclass_s_t_m32_r_t_c_html"><div class="ttname"><a href="class_s_t_m32_r_t_c.html">STM32RTC</a></div><div class="ttdef"><b>Definition</b> STM32RTC.h:75</div></div>
</div><!-- fragment --><p>The following functions are not supported:</p>
<ul>
<li>**<code>void standbyMode()</code>**: use the STM32 Low Power library instead.</li>
<li>**<code>uint8_t getAlarmMonth()</code>**: month not supported by STM32 RTC architecture.</li>
<li>**<code>uint8_t getAlarmYear()</code>**: year not supported by STM32 RTC architecture.</li>
<li>**<code>void setAlarmMonth(uint8_t month)</code>**: month not supported by STM32 RTC architecture.</li>
<li>**<code>void setAlarmYear(uint8_t year)</code>**: year not supported by STM32 RTC architecture.</li>
<li>**<code>void setAlarmDate(uint8_t day, uint8_t month, uint8_t year)</code>**: month and year not supported by STM32 RTC architecture.</li>
</ul>
<p>The following functions have been added to support specific STM32 RTC features:</p>
<p><em>RTC hours mode (12 or 24)</em></p><ul>
<li>**<code>void begin(Hour_Format format)</code>**</li>
</ul>
<p><em>RTC clock source</em></p><ul>
<li>**<code>Source_Clock getClockSource(void)</code>** : get current clock source.</li>
<li>**<code>void setClockSource(Source_Clock source, uint32_t predivA, uint32_t predivS)</code>** : set the clock source (<code>LSI_CLOCK</code>, <code>LSE_CLOCK</code> or <code>HSE_CLOCK</code>) and (a)synchronous prescaler values. This function must be called before <code>begin()</code>. Use <code>(PREDIVA_MAX + 1)</code> and <code>(PREDIVS_MAX +1)</code> to reset value and use computed ones. Those values have to match the following conditions: **_1Hz = RTC CLK source / ((predivA + 1) * (predivS + 1))_**</li>
</ul>
<p><em>RTC Asynchronous and Synchronous prescaler</em></p><ul>
<li>**<code>void getPrediv(uint32_t *predivA, uint32_t *predivS)</code>** : get (a)synchronous prescaler values if set else computed ones for the current clock source.</li>
<li>**<code>void setPrediv(uint32_t predivA, uint32_t predivS)</code>** : set (a)synchronous prescaler values. This function must be called before <code>begin()</code>. Use <code>(PREDIVA_MAX + 1)</code> and <code>(PREDIVS_MAX +1)</code> to reset value and use computed ones. Those values have to match the following conditions: **_1Hz = RTC CLK source / ((predivA + 1) * (predivS + 1))_**</li>
</ul>
<p><em>SubSeconds management</em></p><ul>
<li>**<code>uint32_t getSubSeconds(void)</code>**</li>
<li>**<code>void setSubSeconds(uint32_t subSeconds)</code>**</li>
</ul>
<p><em>Hour format (AM or PM)</em></p><ul>
<li>**<code>uint8_t getHours(AM_PM *period = nullptr)</code>**</li>
<li>**<code>void setHours(uint8_t hours, AM_PM period = AM)</code>**</li>
<li>**<code>void setTime(uint8_t hours, uint8_t minutes, uint8_t seconds, uint32_t subSeconds = 1000, AM_PM period = AM)</code>**</li>
<li>**<code>void setAlarmHours(uint8_t hours, AM_PM period = AM)</code>**</li>
<li>**<code>uint8_t getAlarmHours(AM_PM *period)</code>**</li>
<li>**<code>void setAlarmTime(uint8_t hours, uint8_t minutes, uint8_t seconds, AM_PM period)</code>**</li>
</ul>
<p><em>Week day configuration</em></p><ul>
<li>**<code>uint8_t getWeekDay(void)</code>**</li>
<li>**<code>void setWeekDay(uint8_t weekDay)</code>**</li>
<li>**<code>void setDate(uint8_t weekDay, uint8_t day, uint8_t month, uint8_t year)</code>**</li>
</ul>
<p><em>Time and date configuration (added for convenience)</em></p><ul>
<li>**<code>void getTime(uint8_t *hours, uint8_t *minutes, uint8_t *seconds, uint32_t *subSeconds, AM_PM *period = nullptr)</code>**</li>
<li>**<code>void getDate(uint8_t *weekDay, uint8_t *day, uint8_t *month, uint8_t *year)</code>**</li>
</ul>
<h3><a class="anchor" id="autotoc_md3"></a>
Since STM32RTC version higher than 1.0.3</h3>
<p><em>SubSeconds alarm management</em></p>
<p>Important note:</p><ul>
<li>STM32F1 and STM32L1xx (Ultra Low Power Medium (ULPM) density) series do not support subsecond.</li>
<li>Subsecond “resolution” depends on synchronous prescaler value. Bigger than this value is, better resolution will get for subsecond.</li>
<li>**<code>void setAlarmSubSeconds(uint32_t subSeconds)</code>**</li>
<li><b>Updated API:</b><ul>
<li>**<code>void setAlarmTime(uint8_t hours, uint8_t minutes, uint8_t seconds, uint32_t subSeconds = 0, AM_PM period = AM)</code>**</li>
<li>**<code>uint32_t getEpoch(uint32_t *subSeconds = nullptr)</code>**</li>
<li>**<code>void setEpoch(uint32_t ts, uint32_t subSeconds = 0)</code>**</li>
<li>**<code>void setAlarmEpoch(uint32_t ts, Alarm_Match match = MATCH_DHHMMSS, uint32_t subSeconds = 0)</code>**</li>
</ul>
</li>
</ul>
<p><em>Library version management</em></p>
<p>STM32 RTC library version is based on Semantic Versioning 2.0.0 (<a href="https://semver.org/">https://semver.org/</a>)</p>
<p>This will ease some dependencies:</p>
<ul>
<li><code>STM32_RTC_VERSION_MAJOR</code> -&gt; major version</li>
<li><code>STM32_RTC_VERSION_MINOR</code> -&gt; minor version</li>
<li><code>STM32_RTC_VERSION_PATCH</code> -&gt; patch version</li>
<li><code>STM32_RTC_VERSION_EXTRA</code> -&gt; Extra label with:<ul>
<li>0: official release</li>
<li>[1-9]: release candidate</li>
<li>F[0-9]: development</li>
</ul>
</li>
<li><code>STM32_RTC_VERSION</code> --&gt; Full version number</li>
</ul>
<p><code>STM32_RTC_VERSION</code> can de used to handle some API change: </p><div class="fragment"><div class="line"> ++</div>
<div class="line"><span class="preprocessor">#if defined(STM32_RTC_VERSION) &amp;&amp; (STM32_RTC_VERSION  &gt;= 0x01010000)</span></div>
<div class="line">  rtc.<a class="code hl_function" href="class_s_t_m32_r_t_c.html#afc58f0500fdcdb80d1e6953f78ea1b81">setAlarmTime</a>(alarmHours, alarmMinutes, alarmSeconds, 123);</div>
<div class="line"><span class="preprocessor">#else</span></div>
<div class="line">  rtc.<a class="code hl_function" href="class_s_t_m32_r_t_c.html#afc58f0500fdcdb80d1e6953f78ea1b81">setAlarmTime</a>(alarmHours, alarmMinutes, alarmSeconds);</div>
<div class="line"><span class="preprocessor">#endif</span></div>
<div class="ttc" id="aclass_s_t_m32_r_t_c_html_afc58f0500fdcdb80d1e6953f78ea1b81"><div class="ttname"><a href="class_s_t_m32_r_t_c.html#afc58f0500fdcdb80d1e6953f78ea1b81">STM32RTC::setAlarmTime</a></div><div class="ttdeci">void setAlarmTime(uint32_t subSeconds, Alarm name=ALARM_A)</div><div class="ttdoc">set RTC alarm time.</div><div class="ttdef"><b>Definition</b> STM32RTC.cpp:992</div></div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md4"></a>
Since STM32RTC version higher than 1.1.1</h3>
<p><em>One-Second interrupt</em></p>
<p>STM32 RTC includes a one-second interrupt for generating a periodic interrupt signal.</p><ul>
<li>This feature is native on the stm32F1xx and mapped on the existing WakeUp interrupt on other stm32 mcus.</li>
<li>It is not available on some stm32F0 devices.</li>
<li><b>new API:</b><ul>
<li>**<code>void attachSecondsInterrupt(voidFuncPtr callback)</code>**</li>
<li>**<code>void detachSecondsInterrupt(void)</code>**</li>
</ul>
</li>
</ul>
<p><em>Date retention for stm32F1xx</em></p>
<p>STM32 RTC includes date save/retrieve mechanism for the stm32F1xx mcu, that do not have a date counter.</p>
<p>The content is stored in BackUp memory which is kept during Reset and powered by Vbat when the Vdd is off.</p>
<h3><a class="anchor" id="autotoc_md5"></a>
Since STM32 Core version &gt; 1.5.0</h3>
<p><em>Reset time management</em></p>
<p>By default, if a time is set it will not be reset after a reboot.</p>
<p>Using <code>begin(true)</code> or <code>begin(true, HOUR_24)</code> will reset the RTC registers.</p>
<p>To know if a time has already been set use:</p><ul>
<li>**<code>bool isTimeSet(void)</code>** <div class="fragment"><div class="line">++</div>
<div class="line"> <span class="keywordflow">if</span> (!rtc.isTimeSet()) {</div>
<div class="line">   <span class="comment">// Set the time</span></div>
<div class="line">   rtc.<a class="code hl_function" href="class_s_t_m32_r_t_c.html#a8b63ef8d27d7c186d81939cf7c1a337b">setHours</a>(hours);</div>
<div class="line">   rtc.<a class="code hl_function" href="class_s_t_m32_r_t_c.html#aac020fa0b2694161134a51f4494e42ee">setMinutes</a>(minutes);</div>
<div class="line">   rtc.<a class="code hl_function" href="class_s_t_m32_r_t_c.html#a92a1e8f507d81da11536d6830eb3526c">setSeconds</a>(seconds);</div>
<div class="line"> }</div>
<div class="ttc" id="aclass_s_t_m32_r_t_c_html_a8b63ef8d27d7c186d81939cf7c1a337b"><div class="ttname"><a href="class_s_t_m32_r_t_c.html#a8b63ef8d27d7c186d81939cf7c1a337b">STM32RTC::setHours</a></div><div class="ttdeci">void setHours(uint8_t hours, AM_PM period=AM)</div><div class="ttdoc">set RTC hours.</div><div class="ttdef"><b>Definition</b> STM32RTC.cpp:719</div></div>
<div class="ttc" id="aclass_s_t_m32_r_t_c_html_a92a1e8f507d81da11536d6830eb3526c"><div class="ttname"><a href="class_s_t_m32_r_t_c.html#a92a1e8f507d81da11536d6830eb3526c">STM32RTC::setSeconds</a></div><div class="ttdeci">void setSeconds(uint8_t seconds)</div><div class="ttdoc">set RTC seconds.</div><div class="ttdef"><b>Definition</b> STM32RTC.cpp:688</div></div>
<div class="ttc" id="aclass_s_t_m32_r_t_c_html_aac020fa0b2694161134a51f4494e42ee"><div class="ttname"><a href="class_s_t_m32_r_t_c.html#aac020fa0b2694161134a51f4494e42ee">STM32RTC::setMinutes</a></div><div class="ttdeci">void setMinutes(uint8_t minutes)</div><div class="ttdoc">set RTC minutes.</div><div class="ttdef"><b>Definition</b> STM32RTC.cpp:703</div></div>
</div><!-- fragment --></li>
</ul>
<h3><a class="anchor" id="autotoc_md6"></a>
Since STM32RTC version higher than 1.3.4</h3>
<p><em>Second alarm (Alarm B)</em></p>
<p>Some STM32 RTC have a second alarm named <code>RTC_ALARM_B</code>. It is possible to use it thanks all alarm API with an extra argument:</p><ul>
<li><code>STM32RTC::ALARM_A</code></li>
<li><code>STM32RTC::ALARM_B</code></li>
</ul>
<div class="fragment"><div class="line">++</div>
<div class="line">   rtc.<a class="code hl_function" href="class_s_t_m32_r_t_c.html#adcd5814091cef21194dd142ac25eb9ee">attachInterrupt</a>(myCallback, &amp;myCallbackdata, STM32RTC::ALARM_B);</div>
<div class="line">   rtc.<a class="code hl_function" href="class_s_t_m32_r_t_c.html#a02cbce8c6dd4d601ba8b183afccb0c2d">setAlarmDay</a>(day, STM32RTC::ALARM_B);</div>
<div class="line">   rtc.<a class="code hl_function" href="class_s_t_m32_r_t_c.html#afc58f0500fdcdb80d1e6953f78ea1b81">setAlarmTime</a>(hours, minutes, seconds + 5, 567, STM32RTC::ALARM_B);</div>
<div class="line">   rtc.<a class="code hl_function" href="class_s_t_m32_r_t_c.html#afac46f3b1ba34a56d86fdd4dca26d0f4">enableAlarm</a>(rtc.MATCH_DHHMMSS, STM32RTC::ALARM_B);</div>
<div class="ttc" id="aclass_s_t_m32_r_t_c_html_a02cbce8c6dd4d601ba8b183afccb0c2d"><div class="ttname"><a href="class_s_t_m32_r_t_c.html#a02cbce8c6dd4d601ba8b183afccb0c2d">STM32RTC::setAlarmDay</a></div><div class="ttdeci">void setAlarmDay(uint8_t day, Alarm name=ALARM_A)</div><div class="ttdoc">set RTC alarm day.</div><div class="ttdef"><b>Definition</b> STM32RTC.cpp:1050</div></div>
<div class="ttc" id="aclass_s_t_m32_r_t_c_html_adcd5814091cef21194dd142ac25eb9ee"><div class="ttname"><a href="class_s_t_m32_r_t_c.html#adcd5814091cef21194dd142ac25eb9ee">STM32RTC::attachInterrupt</a></div><div class="ttdeci">void attachInterrupt(voidFuncPtr callback, Alarm name)</div><div class="ttdoc">attach a callback to the RTC alarm interrupt.</div><div class="ttdef"><b>Definition</b> STM32RTC.cpp:293</div></div>
<div class="ttc" id="aclass_s_t_m32_r_t_c_html_afac46f3b1ba34a56d86fdd4dca26d0f4"><div class="ttname"><a href="class_s_t_m32_r_t_c.html#afac46f3b1ba34a56d86fdd4dca26d0f4">STM32RTC::enableAlarm</a></div><div class="ttdeci">void enableAlarm(Alarm_Match match, Alarm name=ALARM_A)</div><div class="ttdoc">enable the RTC alarm.</div><div class="ttdef"><b>Definition</b> STM32RTC.cpp:212</div></div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md7"></a>
Since STM32RTC version higher than 1.3.7</h3>
<p><em>Get the RTC handle</em></p>
<ul>
<li>**<code>RTC_HandleTypeDef *RTC_GetHandle(void)</code>**</li>
</ul>
<p><em>binary and mix modes</em></p>
<p>Some STM32 RTC have a binary mode with 32-bit free-running counter in addition to their BCD mode for calendar (for example stm32wl55). Combined with BCD this is the MIX mode. Only using the binary counter is the BIN mode. Three RTC functional modes are available:</p><ul>
<li><code>STM32RTC::MODE_BCD</code></li>
<li><code>STM32RTC::MODE_MIX</code></li>
<li><code>STM32RTC::MODE_BIN</code></li>
</ul>
<p>**<code>Binary_Mode getBinaryMode(void);</code>**</p><ul>
<li>**<code>void setBinaryMode(Binary_Mode mode);</code>**</li>
</ul>
<p>Any API using the Subsecond parameter is expressed in milliseconds whatever the RTC input clock. This parameter is [0..999] in MIX or BCD mode and [0..0xFFFFFFFF] in BIN mode. In BIN only mode, time and date registers are not used by the RTC. Thus the getEpoch function is only to be called to get the subsecond [0..0xFFFFFFFF] (returned time_t is not valid). The setAlarmEpoch only uses the sub-second [0..0xFFFFFFFF] (time_t value is useless).</p>
<p><em>SubSeconds underflow</em></p>
<p>Only dor STM32WLxx. Manage interrupt (SSRU) when SubSeconds register underflow. Used by STM32LoRaWAN.</p>
<ul>
<li>**<code>void attachSubSecondsUnderflowInterrupt(voidFuncPtr callback);</code>**</li>
<li>**<code>void detachSubSecondsUnderflowInterrupt(void);</code>**</li>
</ul>
<p>Refer to the Arduino RTC documentation for the other functions <a href="http://arduino.cc/en/Reference/RTC">http://arduino.cc/en/Reference/RTC</a></p>
<h3><a class="anchor" id="autotoc_md8"></a>
Since STM32RTC version higher than 1.4.0</h3>
<p><em>IsFormat_24Hour</em></p>
<p>Returns True if the current Hour Format is HOUR_24 else false if Hour format is HOUR_12</p>
<h2><a class="anchor" id="autotoc_md9"></a>
Source</h2>
<p>Source files available at: <a href="https://github.com/stm32duino/STM32RTC">https://github.com/stm32duino/STM32RTC</a> </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.10.0
</small></address>
</body>
</html>
